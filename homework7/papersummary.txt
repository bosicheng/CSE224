# Your paper summary goes here:

PID: A53271697

Summary:
When making a remote call, five pieces of program are involved:the user, the user-stub, the RPC communications package(known as RPCRuntime),the server-stub, the server. The user, the user-stub, and one instance of RPCRuntime execute in the caller machine; the server, the server-stub and another instance of RPCRuntime execute in the callee machine. When the user wishes to make a remote call, it actually makes a perfectly normal local call which invokes a corresponding procedure in the user-stub. The user-stub is responsible for placing a specification of the target procedure and the arguments into one or more packets and asking the RPCRuntime to transmit these reliably to the callee machine. On receipt of these packets, the RPCRuntime in the callee machine passes them to the server-stub. The server-stub unpacks them and again makes a perfectly normal local call, which invokes the appropriate procedure in the server. Meanwhile, the calling process in the caller machine is suspended awaiting a result packet. When the call in the server completes, it returns to the server-stub and results are passed back to the suspended process in the caller machine. There they unpacked and the user-stub returns them to the user. RPCRuntime is responsible for retransmissions, acknowledgements, packet routing, and encryption. An interface module is mainly a list of procedure names, together with the types of their arguments and results. This is sufficient information for the caller and callee to independently perform compile-time type checking and to generate appropriate calling sequence. A program module that implements procedures in an interface is said to export that interface. 

In my opinion, its advantage is it makes it easier to build distributed computations, and to get them right.There're two aspects: one is clean and simple semantics: these should make it easier to build distributed computations, and to get them right. Another is efficiency: procedure calls seem simple enough for the communication to be quite rapid. A third is generality: in single-machine computations, procedures are often the most important mechanism for communication between parts of the algorithm.

This design is relevant for today’s distributed systems.  They represent a particular point in the design spectrum of RPC. It provides some concepts which are adopted today.





PID: A53285138
This paper describes a remote procedure call package, which includes the structure of RPC mechanism, facilities and the transport level communication protocol. Also, in order to evaluate the property of this package, this paper also includes some experiments to measure the performance of this RPC package.
As the existing communication mechanisms largely constrain further development of distributed computing, the author and his team members are trying to design a RPC project to make distributed computing easier. Besides, the RPC project described in this paper also achieve the goals of high-efficiency and high-security. There are five parts included while making a remote call: the user, the user stub, the server, the server stub, and RPC communication package. The stubs are the most basic and important concept in this RPC structure design. The user stubs are used to place specification into one or more packets and adopt the RPC Runtime to transmit these information to callee. The server stubs receive and unpack these packets and start a local call. The RPC project in this paper adopt the name of interfaces , which includes the type and the instance, to help the client to find what he wants to bind with, and use the Grapevine distributed database, which consists of a set of entries, namely Grapevine RName to locate an appropriate exporter.
There are many advantages while adopting the RPC mechanism described in this paper. First of all, exporting machine will not run into trouble while hundreds of users binding to the same server and importer crash happens. The reason is that the export machine will not influence by importing an interface by users. Secondly, the binding are implicitly broken when problems happen in exporters. Moreover, this RPC scheme only allows calls be made on procedures that have been explicitly exported with RPC mechanism. Meanwhile, this scheme also take the secure problem into consideration. The RPC package includes facilities for encryption-based security which solve the problem of eavesdropping. Compare to several advantages, this RPC project also has disadvantages. For instance, it is uncertain whether the performance of this RPC project can remains good while using general purpose transport protocol.
From my perspective, this design is presented relevant for today’s distributed systems. It has been successfully used on several projects. Many concepts described in this paper are still being adopted in today’s distributed systems. Although further experiments need to be done for this RPC project, it has shown its universality to some extent.
